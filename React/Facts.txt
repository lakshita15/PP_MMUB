HOF=> High order function => they do either of these 2 things:-
1. Return A function
2. Accept function as an arguement

Map function:-
1. It takes a function as an arguement.
2.Return a new array.
3.The function gets an element.IT reads each element of thet array and internally passes it to the function.
4.It is used to manupulate same logic on each and every element of array.

Filter Function:-
1. We send a condition.
2.It filter outs the elemengt based on the condition provided.
3. It takes a function as an arguement.
4.Return a new array.
5.The function gets an element.IT reads each element of thet array and internally passes it to the function.

DESTRUCTURING OF ARRAYS:-
The left hand side catches the values from RHS.
eg:-
let person = [abc , def , delhi]
let[name,surname,place] = person;
name me aa jayega abc , surname me def , place me delhi

If the number of variables passed to the destructuring array literals are more than the elements in the array, then the variables which aren’t mapped to any element in the array return undefined.

In an array destructuring from an array of length N specified on the right-hand side of the assignment, if the number of variables specified on the left-hand side of the assignment is greater than N, only the first N variables are assigned values. The values of the remaining variables will be undefined.

//Assigning value  to new variable names
A property can be taken from an object and assigned to a variable with a different name than the object property.

const o = {p: 42, q: true};
const {p: foo, q: bar} = o;

console.log(foo); // 42
console.log(bar); // true

Here, for example, const {p: foo} = o takes from the object o the property named p and assigns it to a local variable named foo.


//skip a value 
1. You can ignore or skip the other elements in the array by using trailing commas.
let[name,,place] = person;
if we will console it'll give only name and place

//giving default values

eg1:-
let[name="kl",surname="lk",place = "noida"] = person;
console pe 
name = kl , surname = lk , place = noida.

eg-2:-
let[name="kl",surname="lk",place = "noida"] = ["ghi"];
console pe 
name = ghi , surname = lk , place = noida. 
name will not take default value if RHS has some parameter passed.

//DESTRUCTURING OF OBJECTS

1.Use curly braces.
2.LHS the values should be equal to valid keys passed.
3.If the key is not present in LHS then it'll give undefined.

//ALIAS

Previously we were getting values on basis of key names but now if we want to change the names of these variables we use alias method.
1. Use (:) colon and then your preferred name
2. Now the key values wont be accessible if  you'll use ALIAS.

//DESTRUCTURING IN NESTED OBJECTS

(:) dalke {}BRACES se next object me chle jayenge.
Get into object ka object 
eg:-let {education:{school:{name}}}=user; 


//SPREAD OPERATOR


//ON ARRAYS

Syntax : ...
iterative elements ko expand.


If we need to concatenate 2 ARRAYS
let new = {...a1 , 5 , ...a2}

We always change in a new array as:-
1. If we just change in the samee array it is mutable change.In React we don't do mutable changes. We always create a new array/object to  do our work.

//ON OBJECTS
let objClone = { ...obj }; // pass all key:value pairs from an object .
Memory me ek new object bn jaata h 

Arrays, Objects , Function are stored in HEAP MEMORY.
//REFERENCE COPY 
EG->let state ={
    name:'John',
    address:{
        city:'London',
        country:{
            countryName:'United Kingdom',
            countryCode:'UK'
        }
    }
}
// let copy = state;
// copy.name = 'Tushar';=====|
// console.log(state);       | => isme output same as both state and copy point to same address/mem location
// console.log(copy);========|

// let copy = {...state} // create new object in memory 
// copy.name = 'Tushar';
// console.log(state); ========|
// console.log(copy);          | ==>>isme output diff  as both state and copy don't point to same address/mem location.When i'll change
// copy.address.city='Delhi';  |     name it will only be reflected in copy but when i'll change city it'll be changed in both state 
// console.log(state);         |     and copy as address same. Usko change krne ke lie aage usko nest krna pdega then we'll make double
// console.log(copy);  ========|     copy

//This is known as our shallow copy

 Shallow copy in this context means that for any given object that is spread, the uppermost level
 of the new variable is an object containing the same property values of the original object, but at a new
 refrence in the memory.
 Any lower level nested objects however, will keep on  ointing to their original refrences.
 in hindi:-
 UPAR UPAR SE CHANGES HONGE INTERNALLY NO CHANGE. 
If i have nested object and we use ... then copy will be made of upper level not lower level.


//double copy

let doublecopy = {   =========|
    ...state,                 |=>state is upper level copy
    address:{                 |=> address ke object ki bhi copy bni h and uske ander jake we spread the address using
        ...state.address ,    |    spread optr.Now name and address point to new address bt countryname point to state vala address
        country:{             |=> to change country name we get into the country object in address and spread country then this country
      ...state.address.country|   will point to new address and all references will be changed and no same changes will be reflected in 
         }                    |   both the state and copy.
    }                         |   //deep copy
}  ===========================|

//if given 50 copies use stringify and parseInt

JSON.stringify(pass an object) => use to convert object to string.
JSON.parse(pass an object) => convert string to object 
And by this we don't need nesting and no changes get reflected in Deepcopy and state


//THIS 
It is a keyword that particularly refer to an object. 
This is used for function calling.
The value of this will change according to the context in which it is referred to.

//GLOBAL EXECUTION context

By default, the execution context for an execution is global — which means if a code is being executed as part of a simple function call, then this refers to a global object.

The window object is the global object in the case of the browser.

The value of THIS in a function depends on how we've called the function.(in abc.js)

*When THIS is called without any  object it is equal to the window object.

*When THIS is called with object it is equal to the object through which the function is called.

*When THIS is called by defination of a fuction that is present in an object then it is equal to the window 

//BIND
The bind() method is defined on other functions and is only called on a function

bind returns a new function whose definition is similar to the function on which it is called and whose this is explicitly set equal to the argument that is passed

//ARROW Function
*SYNTAX
let identifier = (//arguments if any)=>{

}
//Diff between arror fnc and Nrml fnc
Arrow func====>>>> 
1.The value of "THIS" of Arrow function is fiexd to it's lexical enviroment 
Lexcical Enviroment:- Takes it's upper level scope (i.e arrow fnc ke bhr ke this ko apne this ke equal kr deta hai ).
Nrml func====>>>
1.The value of "THIS" of Nrml function depends on how the function is been called.

//CLASSES
The class give us a template or a bluePrint.
It provides a structure.
*SYNTAX
class abc{
    //abc is class name 

    constructor(person){
        //In the constructor only data members can be added
        this.person = person;
        this.age = 10;
    }
    //member functions called outside the constructor
    //no need to write function automatically makes it a function
    sayshi(){
        -----
    }
    
}

Class is just a blueprint so it needs to be defined to do this we have objects
OBJECTS are instance of class. Assign meaning to a  class

The value of "THIS" in class is equal to the object of that class (in class.js)

//BIND FUNCTION IN CLASSES
wE know bind is called on a fnc, sayshi is a function and when we will  call bind on this fnc no change on says hi
This bind will return a function. 
Iss function ko catch in new data member a good prcts is to catch the changes where they have been changed.
this catched this will be equal to the object(in class.js)

//ARROW FUNCTION IN CLASSES
Automatically make default data member 
sayhi this = obj ka this


/************************************************REACT************************************************/

React is JS library to build UI.
UI is managed by state.

COMPONNETS=> The COMPONNETS in react are independant , isolated and reusable.
2types- 1. class based components 2. function based components

//BABEL
In react the code is written in JSX. 
JSX is the mixture of HTML , CSS,JS.
Browser can't understand JSX and can only understand js

babel is medium to convert jsx=>js

Functional components Syntax
function hello(){
    return(
        //jsx code
    )
}

//Render=> takes the components on ui , reflect changes
To attatch the comp or call fnc we use Render
ReactDOM.render(comp whose material is needed , where to attatch);
eg:-ReactDOM.render(<Hellos/>,document.getElementById('root')); => hellos ka data id pe attatch krdo

React.Fragment is used to wrap the multiple items and render it.

in react we can only use 
?=>ternary operator =====|
map fnc                  | => these restrictions are only for return block
no loops         ========|

Props send data from parent to child
passed to arguement of a function

//static ui use =>function components
//dynamic => use class components because they have state

//STATE
It enables the dynamic nature.
It is built in react OBJECT used to contain data or info about components
Whenever state changes the components re render themselves

 this.state.count= this.state.count+1; never ever change the state of react  directly
 this.setState => use this to change the state 

super();//isse hume this milta h class ka


//SEARCHING
searching temporary operation
jo ki har render pe perform 
state capture jese ip box me chng state set render again
text type basis pe search 
new array will be made that is initially empty
To check we use includes method

The includes() method determines whether an array includes a certain value among its entries, returning true or false as appropriate.
It return a  Boolean which is true if the value searchElement is found within the array (or the part of the array indicated by the index fromIndex, if specified)
//Syntax:- includes(searchElement, fromIndex)


//SORTING
We call the sort function on an array.
It return a new array. And no copy is made
It first convers to the string then compares the values or sort.
Give a compare function.
It takes 2 arguements (a,b)

If compareFunction(a, b) returns a value > than 0, sort b before a.
If compareFunction(a, b) returns a value ≤ 0, leave a and b in the same order.

//slice method

The slice() method returns a shallow copy of a portion of an array into a new array object selected from start to end (end not included) where start and end represent the index of items in that array. The original array will not be modified.

/***********************life cycle methods***********************/
3 phases
1.Mounting phase 
2.update
3.Unmount
MOUNTING:- CONSTRUCTOR => RENDER => COMPONENTDIDMOUNT
UPDATE:- RENDER=> COMPONENTDIDUPDATE (only render as update time state change and we know when state changes it renders again)
UNMOUNT :- COMPONENTWILLUNMOUNT

What do we do in ComponentDidMount?
We create side effects.Side Effects basically are network requests on Browser.
componentDidMount() is invoked immediately after a component is mounted (inserted into the tree).

Axios:- Promisified library(Promise based HTTP client for the browser and node.js)
installation:- npm i axios.

/***********************Routing***********************/

 A <Switch> looks through its children <Route>s and
 renders the first one that matches the current URL.
 exact keyword make the component match exactly to path and then only renders it.

 <Link>
 Provides declarative, accessible navigation around your application.
<Link to="/about"> basically we write ki link kha pe => link to this path

 /***********************HOOKS***********************/
 Hooks:- Hooks are the functions that let you hook into the react state & lifecycle methods from functional components..
 Hooks don't work in class components.
 Called inside a function
It let's functional components to make their state and lifecycles.
It lets us add local state to React function components 

Need?
1.Escape boiler plate code ffrom class components.
2.No worries to handle this.
3.Seperation of logics.
 ***********************useState***********************/
useState:- It is a Hook.
useState returns a pair: the current state value and a function that lets you update it.
Funnction is  similar to [this.setState] in a class.
The only argument to useState is the initial state.

in class component 
this.state={
    count =0; // ye thi vha initial value that is now passed as an arguement in use state as its initial state.

}
this.setState({
   count: updated value //this updation of state is done by the functiion
    });

Unlike with classes, the state doesn’t have to be an object.
//update state
To updte the state instead of using count: this.state.count + 1  we use 
the function passed to update the state 
  setCount(count-1);

//Reading state
When we want to display the current count in a class, we read this.state.count but here we directly write {function name}

React will then re-render the function component, passing the new count value to it.
//EVERYTIME STATE WILL CHANGE THE WHOLE FUNCTION WILL RE RENDER/EXECUTED.
Will state create again and again?
No, React has implemented hooks in a way that it knows when function has been executed 1 time.Only at this time new state is created and when the function runs again the useState line is skipped in re render.

/***************************diff between usestate and setstate *******************************************/
In setState we only use dto write the key wwhose value needs to be changed and it didn't effect the other values.
In useState whatever will be passed in functiion will get set.

***********************useEffect***********************/
It gives functionality of life cycle methods in class components to functional components.
It is run after rendering of component.

//SYNTAX
useEffect((callback function)=>{
---code---
} , optional dependancy array);

USEEFFCT RUNS AFTER EVERY RENDER.
USESTATE RUNS ONLY ON 1 RENDER.

Variation1:-
1.runs after every render
2.no dependancy array is passed
3.Behaves partially like mixture of componentdidmount and componentdidupdate

Variation2:-
1.runs after 1 render
2."Behaves like componentdidmount so it runs only aafter first render"
3.dependancy array is passed. Empty dependancy array is passed

Variation3:-
1.non empty dependency array it takes values on which work is dependant to decrease uneccessary calls.
2.dependency array k andar the values that we pass only when they change useEffect runs.

Infinite.js is variation of 1 variation:-
1.Here the setcount is changing and calls are getting infinite times as the state changes so we put and empty dependancy array to make the state chng only 1 render.

CLEAN UP:-
React performs the cleanup when the component unmounts.

//if i make it like compdidmout by adding []
 useeffect 1 baar chlega return 1 bar hoga just unmount se pehle in this case it works as comp will unmount.

 WILL=>PEHLE DID=>BAAAD ME 
