HOF=> High order function => they do either of these 2 things:-
1. Return A function
2. Accept function as an arguement

Map function:-
1. It takes a function as an arguement.
2.Return a new array.
3.The function gets an element.IT reads each element of thet array and internally passes it to the function.
4.It is used to manupulate same logic on each and every element of array.

Filter Function:-
1. We send a condition.
2.It filter outs the elemengt based on the condition provided.
3. It takes a function as an arguement.
4.Return a new array.
5.The function gets an element.IT reads each element of thet array and internally passes it to the function.

DESTRUCTURING OF ARRAYS:-
The left hand side catches the values from RHS.
eg:-
let person = [abc , def , delhi]
let[name,surname,place] = person;
name me aa jayega abc , surname me def , place me delhi

If the number of variables passed to the destructuring array literals are more than the elements in the array, then the variables which arenâ€™t mapped to any element in the array return undefined.

In an array destructuring from an array of length N specified on the right-hand side of the assignment, if the number of variables specified on the left-hand side of the assignment is greater than N, only the first N variables are assigned values. The values of the remaining variables will be undefined.

//Assigning value  to new variable names
A property can be taken from an object and assigned to a variable with a different name than the object property.

const o = {p: 42, q: true};
const {p: foo, q: bar} = o;

console.log(foo); // 42
console.log(bar); // true

Here, for example, const {p: foo} = o takes from the object o the property named p and assigns it to a local variable named foo.


//skip a value 
1. You can ignore or skip the other elements in the array by using trailing commas.
let[name,,place] = person;
if we will console it'll give only name and place

//giving default values

eg1:-
let[name="kl",surname="lk",place = "noida"] = person;
console pe 
name = kl , surname = lk , place = noida.

eg-2:-
let[name="kl",surname="lk",place = "noida"] = ["ghi"];
console pe 
name = ghi , surname = lk , place = noida. 
name will not take default value if RHS has some parameter passed.

//DESTRUCTURING OF OBJECTS

1.Use curly braces.
2.LHS the values should be equal to valid keys passed.
3.If the key is not present in LHS then it'll give undefined.

//ALIAS

Previously we were getting values on basis of key names but now if we want to change the names of these variables we use alias method.
1. Use (:) colon and then your preferred name
2. Now the key values wont be accessible if  you'll use ALIAS.

//DESTRUCTURING IN NESTED OBJECTS

(:) dalke {}BRACES se next object me chle jayenge.
Get into object ka object 
eg:-let {education:{school:{name}}}=user; 


//SPREAD OPERATOR


//ON ARRAYS

Syntax : ...
iterative elements ko expand.


If we need to concatenate 2 ARRAYS
let new = {...a1 , 5 , ...a2}

We always change in a new array as:-
1. If we just change in the samee array it is mutable change.In React we don't do mutable changes. We always create a new array/object to  do our work.

//ON OBJECTS
let objClone = { ...obj }; // pass all key:value pairs from an object .
Memory me ek new object bn jaata h 

Arrays, Objects , Function are stored in HEAP MEMORY.
//REFERENCE COPY 
EG->let state ={
    name:'John',
    address:{
        city:'London',
        country:{
            countryName:'United Kingdom',
            countryCode:'UK'
        }
    }
}
// let copy = state;
// copy.name = 'Tushar';=====|
// console.log(state);       | => isme output same as both state and copy point to same address/mem location
// console.log(copy);========|

// let copy = {...state} // create new object in memory 
// copy.name = 'Tushar';
// console.log(state); ========|
// console.log(copy);          | ==>>isme output diff  as both state and copy don't point to same address/mem location.When i'll change
// copy.address.city='Delhi';  |     name it will only be reflected in copy but when i'll change city it'll be changed in both state 
// console.log(state);         |     and copy as address same. Usko change krne ke lie aage usko nest krna pdega then we'll make double
// console.log(copy);  ========|     copy

//This is known as our shallow copy

 Shallow copy in this context means that for any given object that is spread, the uppermost level
 of the new variable is an object containing the same property values of the original object, but at a new
 refrence in the memory.
 Any lower level nested objects however, will keep on  ointing to their original refrences.
 in hindi:-
 UPAR UPAR SE CHANGES HONGE INTERNALLY NO CHANGE. 
If i have nested object and we use ... then copy will be made of upper level not lower level.


//double copy

let doublecopy = {   =========|
    ...state,                 |=>state is upper level copy
    address:{                 |=> address ke object ki bhi copy bni h and uske ander jake we spread the address using
        ...state.address ,    |    spread optr.Now name and address point to new address bt countryname point to state vala address
        country:{             |=> to change country name we get into the country object in address and spread country then this country
      ...state.address.country|   will point to new address and all references will be changed and no same changes will be reflected in 
         }                    |   both the state and copy.
    }                         |   //deep copy
}  ===========================|

//if given 50 copies use stringify and parseInt

JSON.stringify(pass an object) => use to convert object to string.
JSON.parse(pass an object) => convert string to object 
And by this we don't need nesting and no changes get reflected in Deepcopy and state
